Software Development Principles - SOLID
While using OOP paradigm

S - Single Responsibility
Every module or class should be responsible for singe functionality
One Class One Purpose

O - Open closed Principle
Open for extension Closed for modification.
Behaviour should be extendable without modifying the source code.

Example --> Can be implemented with Abstract Base class.
Base class is closed for Modification
Child class is open for extension

L - Liskov Substitution Principle
Behavioral sub-typing is the principle that subclasses should satisfy the expectations
of clients accessing subclass objects through references of superclass type,
not just as regards syntactic safety (absence of method-not-found errors and such)
but also as regards behavioral correctness.

if S is a subtype of T, then objects of type T may be replaced by objects of type S
without breaking the program.

I - Interface Segregation Principle
    A client should not be forced to implement an interface that it does not use
    Using Abstract base classes and inheritance we can achieve this.
    Right abstractions are to be implemented.
    Abstractions are incorrect when a client depends on methods it doesn't use.

    While creating abstractions, if all the logics have something in common, abstract them
    in the abstraction layer, and provide an interface to do the specific activity.
    So you are breaking the functionality to bits and pieces.
    If the bits and pieces are not helping, then there is no need for abstraction.

D - Dependency Inversion Principle
    High-level modules should not depend on low-level modules. Both should depend on abstractions.
    Abstractions should not depend on details. Details should depend on abstractions.

    The Abstract methods should be purely abstract.
    They should not be created based on the details of the child.
    They should be generic enough to be abstract

#TODO - DRY, ACID